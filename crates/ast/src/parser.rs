use crate::{
    self as ast,
    lexer::{lexer, Token, Token::*},
    Spanned,
};
use alloy_dyn_abi::abi::token;
use alloy_primitives::{hex::FromHex, Bytes, U256};
use chumsky::{
    error::Rich,
    extra,
    input::{Input, Stream},
    primitive::just,
    select,
    span::SimpleSpan,
    IterParser, Parser as ChumskyParser,
};
use evm_glue::opcodes::Opcode;
use std::str::FromStr;

// pub fn parse<'src>(src: &'src str) -> Result<ast::Root<'src>, Vec<Rich<'src, char>>> {
//     let tokens = lexer().parse(src).into_result()?;

//     // let token_stream = Stream::from_iter(tokens).spanned(SimpleSpan::new(0, 0));

//     let x = root().parse(tokens.as_slice()).into_result();
//     // let token_spans: Vec<_> = tokens
//     //     .into_iter()
//     //     .map(|(token, span)| (token, SimpleSpan::new(span.start, span.end)))
//     //     .collect();
//     Ok(ast::Root(Box::new([])))
// }

// pub(crate) fn u256_as_push_data<'a, const N: usize>(
//     value: U256,
// ) -> Result<[u8; N], ParseError<usize, Token<'a>, ast::Error>> {
//     if value.byte_len() > N {
//         return Err(ParseError::User {
//             error: ast::Error::Todo(format!("word too large for PUSH{}", N)),
//         });
//     }
//     let input = value.to_be_bytes::<32>();
//     let mut output = [0u8; N];
//     output.copy_from_slice(&input[32 - N..32]);

//     Ok(output)
// }

// pub(crate) fn u256_as_push<'src>(value: U256) -> Opcode {
//     match value.byte_len() {
//         0..=1 => u256_as_push_data::<1>(value).map(Opcode::PUSH1).unwrap(),
//         2 => u256_as_push_data::<2>(value).map(Opcode::PUSH2).unwrap(),
//         3 => u256_as_push_data::<3>(value).map(Opcode::PUSH3).unwrap(),
//         4 => u256_as_push_data::<4>(value).map(Opcode::PUSH4).unwrap(),
//         5 => u256_as_push_data::<5>(value).map(Opcode::PUSH5).unwrap(),
//         6 => u256_as_push_data::<6>(value).map(Opcode::PUSH6).unwrap(),
//         7 => u256_as_push_data::<7>(value).map(Opcode::PUSH7).unwrap(),
//         8 => u256_as_push_data::<8>(value).map(Opcode::PUSH8).unwrap(),
//         9 => u256_as_push_data::<9>(value).map(Opcode::PUSH9).unwrap(),
//         10 => u256_as_push_data::<10>(value).map(Opcode::PUSH10).unwrap(),
//         11 => u256_as_push_data::<11>(value).map(Opcode::PUSH11).unwrap(),
//         12 => u256_as_push_data::<12>(value).map(Opcode::PUSH12).unwrap(),
//         13 => u256_as_push_data::<13>(value).map(Opcode::PUSH13).unwrap(),
//         14 => u256_as_push_data::<14>(value).map(Opcode::PUSH14).unwrap(),
//         15 => u256_as_push_data::<15>(value).map(Opcode::PUSH15).unwrap(),
//         16 => u256_as_push_data::<16>(value).map(Opcode::PUSH16).unwrap(),
//         17 => u256_as_push_data::<17>(value).map(Opcode::PUSH17).unwrap(),
//         18 => u256_as_push_data::<18>(value).map(Opcode::PUSH18).unwrap(),
//         19 => u256_as_push_data::<19>(value).map(Opcode::PUSH19).unwrap(),
//         20 => u256_as_push_data::<20>(value).map(Opcode::PUSH20).unwrap(),
//         21 => u256_as_push_data::<21>(value).map(Opcode::PUSH21).unwrap(),
//         22 => u256_as_push_data::<22>(value).map(Opcode::PUSH22).unwrap(),
//         23 => u256_as_push_data::<23>(value).map(Opcode::PUSH23).unwrap(),
//         24 => u256_as_push_data::<24>(value).map(Opcode::PUSH24).unwrap(),
//         25 => u256_as_push_data::<25>(value).map(Opcode::PUSH25).unwrap(),
//         26 => u256_as_push_data::<26>(value).map(Opcode::PUSH26).unwrap(),
//         27 => u256_as_push_data::<27>(value).map(Opcode::PUSH27).unwrap(),
//         28 => u256_as_push_data::<28>(value).map(Opcode::PUSH28).unwrap(),
//         29 => u256_as_push_data::<29>(value).map(Opcode::PUSH29).unwrap(),
//         30 => u256_as_push_data::<30>(value).map(Opcode::PUSH30).unwrap(),
//         31 => u256_as_push_data::<31>(value).map(Opcode::PUSH31).unwrap(),
//         32 => u256_as_push_data::<32>(value).map(Opcode::PUSH32).unwrap(),
//         _ => unreachable!(),
//     }
// }

// pub type Span = SimpleSpan<usize>;

// The type of the input that our parser operates on. The input is the `&[(Token, Span)]` token buffer generated by the
// lexer, wrapped in a `SpannedInput` which 'splits' it apart into its constituent parts, tokens and spans, for chumsky
// to understand.
type ParserInput<'tokens, 'src> = chumsky::input::SpannedInput<
    Token<'src>,
    SimpleSpan<usize>,
    &'tokens [(Token<'src>, SimpleSpan<usize>)],
>;

trait Parser<'tokens, 'src: 'tokens, T>:
    ChumskyParser<
    'tokens,
    ParserInput<'tokens, 'src>,
    T,
    extra::Err<Rich<'tokens, Token<'src>, SimpleSpan<usize>>>,
>
{
}
impl<'tokens, 'src: 'tokens, P, T> Parser<'tokens, 'src, T> for P where
    P: ChumskyParser<
        'tokens,
        ParserInput<'tokens, 'src>,
        T,
        extra::Err<Rich<'tokens, Token<'src>, SimpleSpan<usize>>>,
    >
{
}

fn root<'tokens, 'src: 'tokens>() -> impl Parser<'tokens, 'src, ast::Root<'src>> {
    definition()
        .repeated()
        .collect::<Vec<_>>()
        .map(|defs| ast::Root(defs.into_boxed_slice()))
}

fn definition<'tokens, 'src: 'tokens>() -> impl Parser<'tokens, 'src, ast::Definition<'src>> {
    just(Keyword("define")).ignore_then(constant().or(table()))
}

fn r#macro<'tokens, 'src: 'tokens>() -> impl Parser<'tokens, 'src, ast::Definition<'src>> {
    let macro_args = ident().separated_by(just(Punct(','))).collect::<Vec<_>>();

    just(Ident("macro"))
        .ignore_then(ident())
        .then_ignore(just(Punct('(')))
        .then(macro_args)
        .then_ignore(just(Punct(')')))
        .then_ignore(just(Punct('=')))
        .then(
            just(Ident("takes"))
                .ignore_then(just(Punct('(')))
                .ignore_then(dec())
                .then_ignore(just(Punct(')')))
                .then_ignore(just(Ident("returns")))
                .then_ignore(just(Punct('(')))
                .then(dec())
                .then_ignore(just(Punct(')')))
                .or_not(),
        )
        .then_ignore(just(Punct('{')))
        .then(macro_statement().repeated().collect::<Vec<_>>())
        .then_ignore(just(Punct('}')))
        .map(|(((name, args), takes_returns), body)| ast::Macro {
            name,
            args: args.into_boxed_slice(),
            takes_returns,
            body: body.into_boxed_slice(),
        })
        .map(ast::Definition::Macro)
}

fn macro_statement<'tokens, 'src: 'tokens>() -> impl Parser<'tokens, 'src, ast::MacroStatement<'src>>
{
    let label = ident()
        .then_ignore(just(Punct(':')))
        .map(ast::MacroStatement::LabelDefinition);
    let instruction = instruction().map(ast::MacroStatement::Instruction);
    let invoke = invoke().map(ast::MacroStatement::Invoke);

    label.or(instruction).or(invoke)
}

fn instruction<'tokens, 'src: 'tokens>() -> impl Parser<'tokens, 'src, ast::Instruction<'src>> {
    // TODO push
    let op = ident().map(|(ident, span)| {
        if let Ok(op) = Opcode::from_str(ident) {
            ast::Instruction::Op((op, span))
        } else {
            ast::Instruction::LabelReference((ident, span))
        }
    });
    let macro_arg_ref = just(Punct('<'))
        .ignore_then(ident())
        .then_ignore(just(Punct('>')))
        .map(ast::Instruction::MacroArgReference);
    let constant_ref = just(Punct('['))
        .ignore_then(ident())
        .then_ignore(just(Punct(']')))
        .map(ast::Instruction::ConstantReference);
    op.or(macro_arg_ref).or(constant_ref)
}

fn invoke<'tokens, 'src: 'tokens>() -> impl Parser<'tokens, 'src, ast::Invoke<'src>> {
    let invoke_macro_args = just(Punct('('))
        .ignore_then(
            instruction()
                .separated_by(just(Punct(',')))
                .collect::<Vec<_>>(),
        )
        .then_ignore(just(Punct(')')))
        .map(|args| args.into_boxed_slice());

    let invoke_macro = ident()
        .then(invoke_macro_args)
        .map(|(name, args)| ast::Invoke::Macro { name, args: args });

    let invoke_builtin = |name, constructor: fn((_, SimpleSpan)) -> ast::Invoke<'src>| {
        just(Ident(name))
            .ignore_then(just(Punct('(')))
            .ignore_then(ident())
            .then_ignore(just(Punct(')')))
            .map(constructor)
    };
    let invoke_tablestart = invoke_builtin("__tablestart", ast::Invoke::BuiltinTableStart);
    let invoke_tablesize = invoke_builtin("__tablesize", ast::Invoke::BuiltinTableSize);
    let invoke_codesize = invoke_builtin("__codesize", ast::Invoke::BuiltinCodeSize);
    let invoke_codeoffset = invoke_builtin("__codeoffset", ast::Invoke::BuiltinCodeOffset);
    let invoke_func_sig = invoke_builtin("__FUNC_SIG", ast::Invoke::BuiltinFuncSig);
    let invoke_event_hash = invoke_builtin("__EVENT_HASH", ast::Invoke::BuiltinEventHash);
    let invoke_error = invoke_builtin("__ERROR", ast::Invoke::BuiltinError);

    invoke_macro
        .or(invoke_tablestart)
        .or(invoke_tablesize)
        .or(invoke_codesize)
        .or(invoke_codeoffset)
        .or(invoke_func_sig)
        .or(invoke_event_hash)
        .or(invoke_error)
}

fn constant<'tokens, 'src: 'tokens>() -> impl Parser<'tokens, 'src, ast::Definition<'src>> {
    just(Ident("constant"))
        .ignore_then(ident())
        .then_ignore(just(Punct('=')))
        .then(word())
        .map(|(name, (value, _))| ast::Definition::Constant { name, value })
}

fn table<'tokens, 'src: 'tokens>() -> impl Parser<'tokens, 'src, ast::Definition<'src>> {
    just(Ident("table"))
        .ignore_then(ident())
        .then_ignore(just(Punct('{')))
        .then(code().repeated().collect::<Vec<_>>())
        .then_ignore(just(Punct('}')))
        .map(|(name, code)| ast::Definition::Codetable {
            name,
            data: code
                .into_iter()
                .flatten()
                .collect::<Vec<_>>()
                .into_boxed_slice(),
        })
}

fn ident<'tokens, 'src: 'tokens>() -> impl Parser<'tokens, 'src, Spanned<&'src str>> {
    select! {Ident(s) => s}.map_with(|s, ex| (s, ex.span()))
}

fn dec<'tokens, 'src: 'tokens>() -> impl Parser<'tokens, 'src, Spanned<usize>> {
    select! {Dec(s) => s.parse::<usize>().unwrap()}.map_with(|s, ex| (s, ex.span()))
}

fn word<'tokens, 'src: 'tokens>() -> impl Parser<'tokens, 'src, Spanned<U256>> {
    select! {
        Hex(s) => U256::from_str_radix(&s[2..], 16),
        Bin(s) => U256::from_str_radix(&s[2..], 2),
        Dec(s) => U256::from_str_radix(s, 10)
    }
    .try_map_with(|value, ex| value.map_err(|_e| Rich::custom(ex.span(), "word overflows")))
    .map_with(|value, ex| (value, ex.span()))
}

fn code<'tokens, 'src: 'tokens>() -> impl Parser<'tokens, 'src, Vec<u8>> {
    select! {
        Hex(s) => Bytes::from_hex(s)
    }
    .try_map_with(|code, ex| code.map_err(|_e| Rich::custom(ex.span(), "odd length")))
    .map(|code| code.to_vec())
}

#[cfg(test)]
mod tests {
    use std::vec;

    use super::*;
    use alloy_dyn_abi::DynSolType;
    use alloy_primitives::{hex, ruint, uint, U256};
    use chumsky::input::Input;

    /// Macro to assert that a parser successfully parses a given set of tokens
    /// and produces the expected result.
    ///
    /// # Arguments
    ///
    /// * `$parser` - The parser to be tested.
    /// * `$tokens` - A collection of tokens to be parsed.
    /// * `$expected` - The expected result after parsing.
    macro_rules! assert_ok {
        ($parser:expr, $tokens:expr, $expected:expr) => {
            let tokens: Vec<(Token<'_>, SimpleSpan)> = $tokens
                .into_iter()
                .map(|tok| (tok.clone(), SimpleSpan::new(0, 0)))
                .collect();
            assert_eq!(
                $parser
                    .parse(tokens.as_slice().spanned(SimpleSpan::new(0, 0)))
                    .into_result(),
                Ok($expected),
            );
        };
    }

    /// Macro to assert that a parser returns an expected error when parsing a
    /// given set of tokens.
    ///
    /// # Arguments
    ///
    /// * `$parser` - The parser to be tested.
    /// * `$tokens` - A collection of tokens to be parsed.
    /// * `$expected` - The expected error message after parsing.
    macro_rules! assert_err {
        ($parser:expr, $tokens:expr, $expected:expr) => {
            let tokens: Vec<(Token<'_>, SimpleSpan)> = $tokens
                .into_iter()
                .map(|tok| (tok.clone(), SimpleSpan::new(0, 0)))
                .collect();
            let expected = vec![Rich::custom(SimpleSpan::new(0, 0), $expected)];
            assert_eq!(
                $parser
                    .parse(tokens.as_slice().spanned(SimpleSpan::new(0, 0)))
                    .into_result(),
                Err(expected),
            );
        };
    }

    #[test]
    fn parse_word() {
        let span: SimpleSpan<usize> = SimpleSpan::new(0, 0);

        assert_ok!(word(), vec![Hex("0x0")], (U256::ZERO, span));
        assert_ok!(word(), vec![Hex("0x1")], (uint!(1_U256), span));
        assert_ok!(word(), vec![Bin("0b10")], (uint!(2_U256), span));
        assert_ok!(word(), vec![Dec("2")], (uint!(2_U256), span));
        assert_ok!(
            word(),
            vec![Hex("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")],
            (U256::MAX, span)
        );
        assert_err!(
            word(),
            vec![Hex("0x10000000000000000000000000000000000000000000000000000000000000000")],
            "word overflows"
        );
    }

    #[test]
    fn parse_code() {
        assert_ok!(code(), vec![Hex("0xc0de")], vec![0xc0, 0xde]);
        assert_err!(code(), vec![Hex("0x0")], "odd length");
    }

    #[test]
    fn parse_macro() {
        let span: SimpleSpan<usize> = SimpleSpan::new(0, 0);
        assert_ok!(
            r#macro(),
            vec![
                Ident("macro"),
                Ident("MAIN"),
                Punct('('),
                Punct(')'),
                Punct('='),
                Punct('{'),
                Punct('}')
            ],
            ast::Definition::Macro(ast::Macro {
                name: ("MAIN", span),
                args: Box::new([]),
                takes_returns: None,
                body: Box::new([])
            })
        );
        assert_ok!(
            r#macro(),
            vec![
                Ident("macro"),
                Ident("READ_ADDRESS"),
                Punct('('),
                Ident("offset"),
                Punct(')'),
                Punct('='),
                Ident("takes"),
                Punct('('),
                Dec("0"),
                Punct(')'),
                Ident("returns"),
                Punct('('),
                Dec("1"),
                Punct(')'),
                Punct('{'),
                Ident("stop"),
                Punct('}')
            ],
            ast::Definition::Macro(ast::Macro {
                name: ("READ_ADDRESS", span),
                args: Box::new([("offset", span)]),
                takes_returns: Some(((0, span), (1, span))),
                body: Box::new([ast::MacroStatement::Instruction(ast::Instruction::Op((
                    Opcode::STOP,
                    span
                )))]),
            })
        );
    }

    #[test]
    fn parse_macro_statement() {
        let span: SimpleSpan<usize> = SimpleSpan::new(0, 0);

        assert_ok!(
            macro_statement(),
            vec![Ident("x"), Punct(':')],
            ast::MacroStatement::LabelDefinition(("x", span))
        );
        assert_ok!(
            macro_statement(),
            vec![Ident("__tablestart"), Punct('('), Ident("TABLE"), Punct(')')],
            ast::MacroStatement::Invoke(ast::Invoke::BuiltinTableStart(("TABLE", span)))
        );
        assert_ok!(
            macro_statement(),
            vec![Ident("READ_ADDRESS"), Punct('('), Hex("0x4"), Punct(')')],
            ast::MacroStatement::Invoke(ast::Invoke::Macro {
                name: ("READ_ADDRESS", span),
                args: Box::new([ast::Instruction::Op((Opcode::PUSH1([0x04]), span))])
            })
        );
    }

    #[test]
    fn parse_instruction() {
        let span: SimpleSpan<usize> = SimpleSpan::new(0, 0);

        assert_ok!(
            instruction(),
            vec![Ident("add")],
            ast::Instruction::Op((Opcode::ADD, span))
        );
        assert_ok!(
            instruction(),
            vec![Hex("0x1")],
            ast::Instruction::Op((Opcode::PUSH1([0x01]), span))
        );
        assert_ok!(
            instruction(),
            vec![Ident("push2"), Hex("0x1")],
            ast::Instruction::Op((Opcode::PUSH2([0x00, 0x01]), span))
        );
        assert_ok!(
            instruction(),
            vec![Ident("x")],
            ast::Instruction::LabelReference(("x", span))
        );
        assert_ok!(
            instruction(),
            vec![Punct('<'), Ident("x"), Punct('>')],
            ast::Instruction::MacroArgReference(("x", span))
        );
        assert_ok!(
            instruction(),
            vec![Punct('['), Ident("x"), Punct(']')],
            ast::Instruction::ConstantReference(("x", span))
        );
    }

    #[test]
    fn parse_constant() {
        let span: SimpleSpan<usize> = SimpleSpan::new(0, 0);

        assert_ok!(
            constant(),
            vec![Ident("constant"), Ident("TEST"), Punct('='), Hex("0x1")],
            ast::Definition::Constant {
                name: ("TEST", span),
                value: uint!(1_U256)
            }
        );
    }

    #[test]
    fn parse_table() {
        let span: SimpleSpan<usize> = SimpleSpan::new(0, 0);

        assert_ok!(
            table(),
            vec![Ident("table"), Ident("TEST"), Punct('{'), Hex("0xc0de"), Punct('}')],
            ast::Definition::Codetable {
                name: ("TEST", span),
                data: Box::new([0xc0, 0xde])
            }
        );
        assert_ok!(
            table(),
            vec![
                Ident("table"),
                Ident("TEST"),
                Punct('{'),
                Hex("0xc0de"),
                Hex("0xcc00ddee"),
                Punct('}')
            ],
            ast::Definition::Codetable {
                name: ("TEST", span),
                data: Box::new([0xc0, 0xde, 0xcc, 0x00, 0xdd, 0xee])
            }
        );
    }

    // #[test]
    // fn sol_type_list_parser() {
    //     assert_eq!(
    //         grammar::SolTypeListParser::new().parse("(address, uint256)"),
    //         Ok(vec![
    //             DynSolType::parse("address").unwrap(),
    //             DynSolType::parse("uint256").unwrap()
    //         ]
    //         .into_boxed_slice())
    //     );
    //     assert_eq!(
    //         grammar::SolTypeListParser::new().parse("(address[] tokens)"),
    //         Ok(vec![DynSolType::parse("address[]").unwrap(),].into_boxed_slice())
    //     );
    //     assert_eq!(
    //         grammar::SolTypeListParser::new().parse("(address[3] tokens)"),
    //         Ok(vec![DynSolType::parse("address[3]").unwrap(),].into_boxed_slice())
    //     );
    //     assert_eq!(
    //         grammar::SolTypeListParser::new().parse("((address, (address to, uint256
    // amount)[]))"),         Ok(
    //             vec![DynSolType::parse("(address,(address,uint256)[])").unwrap(),]
    //                 .into_boxed_slice()
    //         )
    //     );
    // }

    // #[test]
    // fn sol_function_parser() {
    //     assert_eq!(
    //         grammar::SolFunctionParser::new()
    //             .parse("function balanceOf(address) returns (uint256)"),
    //         Ok(ast::Definition::SolFunction(ast::SolFunction {
    //             name: "balanceOf",
    //             args: Box::new([DynSolType::parse("address").unwrap()]),
    //             rets: Box::new([DynSolType::parse("uint256").unwrap()]),
    //         }))
    //     );
    // }

    // #[test]
    // fn sol_event_parser() {
    //     assert_eq!(
    //         grammar::SolEventParser::new()
    //             .parse("event Transfer(address from, address to, uint256 value)"),
    //         Ok(ast::Definition::SolEvent(ast::SolEvent {
    //             name: "Transfer",
    //             args: Box::new([
    //                 DynSolType::parse("address").unwrap(),
    //                 DynSolType::parse("address").unwrap(),
    //                 DynSolType::parse("uint256").unwrap()
    //             ]),
    //         }))
    //     );
    // }

    // #[test]
    // fn sol_error_parser() {
    //     assert_eq!(
    //         grammar::SolErrorParser::new().parse("error PanicError(uint256)"),
    //         Ok(ast::Definition::SolError(ast::SolError {
    //             name: "PanicError",
    //             args: Box::new([DynSolType::parse("uint256").unwrap(),]),
    //         }))
    //     );
    // }
}
