use alloy_dyn_abi::DynSolType;
use alloy_primitives::{hex::FromHex, Bytes, U256};
use revm_interpreter::OpCode;
use lalrpop_util::ParseError;
use crate as ast;
use crate::parser::parse_opcode;

grammar;

extern {
    type Error = ast::Error;
}

pub Root: ast::Root<'input> = {
    <def:Definition*> => ast::Root(def.into_iter().collect()),
};

pub Definition: ast::HuffDefinition<'input> = {
    "#define" <m:Macro> => m,
    "#define" <c:Constant> => c,
    "#define" <t:Table> => t,
    "#define" <f:SolFunction> => f,
    "#define" <e:SolEvent> => e,
    "#define" <e:SolError> => e,
};

pub Macro: ast::HuffDefinition<'input> = {
    "macro" <name:IDENT> <args:MacroArgs> "=" "takes" "(" <takes:DEC> ")" "returns" "(" <returns:DEC> ")" "{" <insts:Instruction+> "}" => {
        let takes = takes.parse::<usize>().unwrap();
        let returns = returns.parse::<usize>().unwrap();
        ast::HuffDefinition::Macro(ast::Macro{ name, args, takes, returns, body: insts.into_boxed_slice() })
    }
};

pub MacroArgs: Box<[&'input str]> = {
    "(" ")" => Box::new([]),
    "(" <first:IDENT> <rest:("," IDENT)*> ")" => {
        let mut list = vec![first];
        list.extend(rest.into_iter().map(|(_, t)| t));
        list.into_boxed_slice()
    }
};

pub Instruction: ast::Instruction<'input> = {
    <word:Word> => ast::Instruction::PushAuto(word),
    "push1"  <word:Word> => ast::Instruction::Push(OpCode::PUSH1,  word),
    "push2"  <word:Word> => ast::Instruction::Push(OpCode::PUSH2,  word),
    "push3"  <word:Word> => ast::Instruction::Push(OpCode::PUSH3,  word),
    "push4"  <word:Word> => ast::Instruction::Push(OpCode::PUSH4,  word),
    "push5"  <word:Word> => ast::Instruction::Push(OpCode::PUSH5,  word),
    "push6"  <word:Word> => ast::Instruction::Push(OpCode::PUSH6,  word),
    "push7"  <word:Word> => ast::Instruction::Push(OpCode::PUSH7,  word),
    "push8"  <word:Word> => ast::Instruction::Push(OpCode::PUSH8,  word),
    "push9"  <word:Word> => ast::Instruction::Push(OpCode::PUSH9,  word),
    "push10" <word:Word> => ast::Instruction::Push(OpCode::PUSH10, word),
    "push11" <word:Word> => ast::Instruction::Push(OpCode::PUSH11, word),
    "push12" <word:Word> => ast::Instruction::Push(OpCode::PUSH12, word),
    "push13" <word:Word> => ast::Instruction::Push(OpCode::PUSH13, word),
    "push14" <word:Word> => ast::Instruction::Push(OpCode::PUSH14, word),
    "push15" <word:Word> => ast::Instruction::Push(OpCode::PUSH15, word),
    "push16" <word:Word> => ast::Instruction::Push(OpCode::PUSH16, word),
    "push17" <word:Word> => ast::Instruction::Push(OpCode::PUSH17, word),
    "push18" <word:Word> => ast::Instruction::Push(OpCode::PUSH18, word),
    "push19" <word:Word> => ast::Instruction::Push(OpCode::PUSH19, word),
    "push20" <word:Word> => ast::Instruction::Push(OpCode::PUSH20, word),
    "push21" <word:Word> => ast::Instruction::Push(OpCode::PUSH21, word),
    "push22" <word:Word> => ast::Instruction::Push(OpCode::PUSH22, word),
    "push23" <word:Word> => ast::Instruction::Push(OpCode::PUSH23, word),
    "push24" <word:Word> => ast::Instruction::Push(OpCode::PUSH24, word),
    "push25" <word:Word> => ast::Instruction::Push(OpCode::PUSH25, word),
    "push26" <word:Word> => ast::Instruction::Push(OpCode::PUSH26, word),
    "push27" <word:Word> => ast::Instruction::Push(OpCode::PUSH27, word),
    "push28" <word:Word> => ast::Instruction::Push(OpCode::PUSH28, word),
    "push29" <word:Word> => ast::Instruction::Push(OpCode::PUSH29, word),
    "push30" <word:Word> => ast::Instruction::Push(OpCode::PUSH30, word),
    "push31" <word:Word> => ast::Instruction::Push(OpCode::PUSH31, word),
    "push32" <word:Word> => ast::Instruction::Push(OpCode::PUSH32, word),
    <id:IDENT> => {
        if let Some(op) = parse_opcode(id) {
            ast::Instruction::Op(op)
        } else {
            ast::Instruction::LabelReference(id)
        }
    },
    <label:IDENT> ":" => ast::Instruction::LabelDefinition(label),
    "<" <referenc:IDENT> ">" => ast::Instruction::MacroArgReference(referenc),
    "[" <referenc:IDENT> "]" => ast::Instruction::ConstantReference(referenc),
    <invoke:Invoke> => ast::Instruction::Invoke(invoke),
}

pub Invoke: ast::Invoke<'input> = {
    <name:IDENT> "(" <args:InvokeMacroArgs> ")" => ast::Invoke::Macro{ name, args },
    "__tablestart" "(" <arg:IDENT> ")" => ast::Invoke::BuiltinTableStart(arg),
    "__tablesize" "(" <arg:IDENT> ")" => ast::Invoke::BuiltinTableSize(arg),
    "__codesize" "(" <arg:IDENT> ")" => ast::Invoke::BuiltinCodeSize(arg),
    "__codeoffset" "(" <arg:IDENT> ")" => ast::Invoke::BuiltinCodeOffset(arg),
    "__FUNC_SIG" "(" <arg:IDENT> ")" => ast::Invoke::BuiltinFuncSig(arg),
    "__EVENT_HASH" "(" <arg:IDENT> ")" => ast::Invoke::BuiltinEventHash(arg),
    "__ERROR" "(" <arg:IDENT> ")" => ast::Invoke::BuiltinError(arg),
};

pub InvokeMacroArgs: Box<[U256]> = {
    "(" ")" => Box::new([]),
    "(" <first:Word> <rest:("," Word)*> ")" => {
        let mut list = vec![first];
        list.extend(rest.into_iter().map(|(_, t)| t));
        list.into_boxed_slice()
    }
}

pub Constant: ast::HuffDefinition<'input> = {
    "constant" <name:IDENT> "=" <value:Word> => ast::HuffDefinition::Constant { name, value }
};

pub Table: ast::HuffDefinition<'input> = {
    "table" <name:IDENT> "{" <code:Code+> "}" => {
        let data = code.into_iter().flatten().collect::<Vec<u8>>().into_boxed_slice();
        ast::HuffDefinition::Codetable { name, data }
    },
};

pub SolFunction: ast::HuffDefinition<'input> = {
    "function" <name:IDENT> <args:SolTypeList> <rets:("returns" SolTypeList)?> => {
        let rets = rets.map(|(_, t)| t).unwrap_or_else(|| Box::new([]));
        ast::HuffDefinition::AbiFunction(ast::AbiFunction{ name, args, rets })
    }
};

pub SolEvent: ast::HuffDefinition<'input> = {
    "event" <name:IDENT> <args:SolTypeList> => ast::HuffDefinition::AbiEvent(ast::AbiEvent{ name, args })
};

pub SolError: ast::HuffDefinition<'input> = {
    "error" <name:IDENT> <args:SolTypeList> => ast::HuffDefinition::AbiError(ast::AbiError{ name, args })
};

pub SolTypeList: Box<[DynSolType]> = {
    "(" ")" => Box::new([]),
    "(" <first:SolType> <rest:("," SolType)*>  ")" => {
        let mut list = vec![first];
        list.extend(rest.into_iter().map(|(_, t)| t));
        list.into_boxed_slice()
    }
};

pub SolType: DynSolType = {
    <t:SolRawType> =>? DynSolType::parse(&t).map_err(|e| ParseError::User { error: ast::Error::InvalidSolType(e) })
};

pub SolRawType: String = {
    <t:SolRawPrimitiveType> <ex:("[" DEC? "]")?> IDENT? => {
        let mut result = t.to_string();
        if let Some(ex) = ex {
            result.push_str(ex.0);
            if let Some(num) = ex.1 {
                result.push_str(num);
            }
            result.push_str(ex.2);
        }
        result
    },
    <t:SolRawTupleType> <ex:("[" DEC? "]")?> IDENT? => {
        let mut result = t.to_string();
        if let Some(ex) = ex {
            result.push_str(ex.0);
            if let Some(num) = ex.1 {
                result.push_str(num);
            }
            result.push_str(ex.2);
        }
        result
    },
};

pub SolRawPrimitiveType: &'input str = {
    <t:IDENT> => t
};

pub SolRawTupleType: String = {
    "(" <fist:SolRawType> <rest:("," SolRawType)*> ")" => {
        let mut result = "(".to_string();
        result.push_str(&fist);
        rest.into_iter().for_each(|(_, t)| {
            result.push_str(",");
            result.push_str(&t);
        });
        result.push_str(")");
        result
    }
}

pub Word: U256 = {
    <s:HEX> =>? U256::from_str_radix(&s[2..], 16).map_err(|e| {
        ParseError::User { error: ast::Error::WordOverflow(e) }
    }),
    <s:BIN> =>? U256::from_str_radix(&s[2..], 2).map_err(|e| {
        ParseError::User { error: ast::Error::WordOverflow(e) }
    }),
    <s:DEC> =>? U256::from_str_radix(s, 10).map_err(|e| {
        ParseError::User { error: ast::Error::WordOverflow(e) }
    }),
};

pub Code: Vec<u8> = {
    <s:HEX> =>? Bytes::from_hex(s)
        .map(|b| b.to_vec())
        .map_err(|e| ParseError::User{ error: ast::Error::BytesOddLength(e) })
}

match {
    r"\s+" => {},                  // whitespace
    r"//[^\n\r]*[\n\r]*" => {},    // single-line comments
    r"/\*([^*]|\*[^/])*\*/" => {}, // multi-line comments

    r"[a-zA-Z_][a-zA-Z0-9_]*" => IDENT, // identifier

    r"0|[1-9][0-9]*" => DEC, // decimal number
    r"0x[0-9a-f]+" => HEX,   // hexadecimal number
    r"0b[01]+" => BIN,       // binary number

    _
}
